#!/usr/bin/env python3
import argparse
import sys
import os
import yaml
from tools.codegen.code_template import CodeTemplate
from typing import Dict, List
from enum import Enum

class ByteCode(Enum):
    instructions = 1
    constants = 2
    types = 3
    operators = 4
    register_size = 5

def load_yaml(upgrader_yaml_path):
    with open(upgrader_yaml_path, "rb") as yaml_file:
        return yaml.safe_load(yaml_file)


ONE_INSTRUCTION = CodeTemplate("""
    Instruction{OpCode::${operator_name}, ${X}, ${N}},""")

INSTRUCTION_LIST = CodeTemplate("""std::vector<Instruction>({
        ${instruction_list}
    }), // instructions list""")

ONE_CONSTANT = CodeTemplate("""c10::IValue(${constant}),""")

CONSTANT_LIST = CodeTemplate("""std::vector<c10::IValue>({
        ${constant_list}
    }), // constants list""")

ONE_TYPE = CodeTemplate("""c10::parseType("${type_str}"),""")

TYPE_LIST = CodeTemplate("""std::vector<c10::TypePtr>({
        ${type_list}
    }), // types list""")

ONE_OPERATOTR_STRING = CodeTemplate("""
    OperatorString({"${operator_name}", "${overload_name}", ${num_of_args}}),""")

OPERATOR_STRING_LIST = CodeTemplate("""
    std::vector<OperatorString>({
        ${operator_string_list}
    }), // operators list""")

ONE_UPGRADER_FUNCTION = CodeTemplate("""
    mobile::Function::registerFunc(
        "${upgrader_name}",
        ${instruction_list},
        ${constant_list},
        ${type_list},
        ${register_size}
    )""")

ONE_UPGRADER_SRC = CodeTemplate("""
    ByteCodeFunctionWithOperator({
        ${bytecode_function},
        ${operator_string_list}
    }),""")


UPGRADER_CPP_SRC = CodeTemplate("""#pragma once
/**
 * Generated by gen_mobile_upgraders.py
 */

#include <ATen/core/ivalue_inl.h>
#include <torch/csrc/jit/mobile/code.h>
#include <torch/csrc/jit/mobile/function.h>
#include <torch/csrc/jit/serialization/import_export_functions.h>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

namespace c10 {
TypePtr parseType(const std::string& pythonStr);
} // namespace c10

namespace torch {
namespace jit {

struct Instruction;
struct Upgrader {
  int min_version;
  int max_version;
  std::string upgrader_name;
  int index;
};

// From operator_versions.yaml
const std::unordered_map<std::string, std::vector<Upgrader>> kOperatorVersionMap(
    {
        {std::string("aten::div.Tensor"),
         std::vector<Upgrader>({Upgrader({0, 3, "div_Tensor_0_3", 0})})},
        {std::string("aten::div.Scalar"),
         std::vector<Upgrader>({Upgrader({0, 3, "div_Scalar_0_3", 1})})},
        {std::string("aten::div.out"),
         std::vector<Upgrader>({Upgrader({0, 3, "div_out_0_3", 2})})},
        {std::string("aten::div_.Tensor"),
         std::vector<Upgrader>({Upgrader({0, 3, "div__Tensor_0_3", 3})})},
        {std::string("aten::div_.Scalar"),
         std::vector<Upgrader>({Upgrader({0, 3, "div__Scalar_0_3", 4})})},
    });

struct OperatorString {
  const std::string name;
  const std::string overload_name;
  const c10::optional<int> num_specified_args;
};

struct ByteCodeFunctionWithOperator {
  mobile::Function& function;
  std::vector<OperatorString> operators;
};

static std::vector<ByteCodeFunctionWithOperator> kUpgraderByteCode(
    {
       ${upgrader_bytecode}
    });

} // namespace jit
} // namespace torch

""")

UPGRADER_MOBILE_FILE_NAME = "upgrader_mobile.h"

UPGRADER_ELEMENT = CodeTemplate("""\
Upgrader({${min_version}, ${max_version}, ${operator_name}, ${index}}),
""")

PER_OPERATOR_UPGRADER_LIST = CodeTemplate("""\
{
  std::string(${operator_name}),
  std::vector<Upgrader>({${upgrader_list}});
}
""")

def construct_instruction(instruction_list_from_yaml: List) -> str:
    instruction_list_part = []
    for instruction in instruction_list_from_yaml:
        instruction_list_part.append(
            ONE_INSTRUCTION.substitute(
                operator_name=instruction[0],
                X=instruction[1],
                N=instruction[2],
            )
        )
    return INSTRUCTION_LIST.substitute(instruction_list="".join(instruction_list_part))

def construct_constants(constants_list_from_yaml: List) -> str:
    constants_list_part = []
    for constant_from_yaml in constants_list_from_yaml:
        print("CONSTANT: ", constant_from_yaml, " type: ", type(constant_from_yaml))
        convert_constant = None
        if isinstance(constant_from_yaml, str):
            # Add quotes if it's string
            convert_constant = f'"{constant_from_yaml}"'
        elif isinstance(constant_from_yaml, bool):
            convert_constant = "true" if constant_from_yaml else 'false'
        else:
            raise ValueError(f"The type of {constant_from_yaml} is {type(constant_from_yaml)}. Please add change in construct_constants function in gen_mobile_upgraders.py.")
        constants_list_part.append(
            ONE_CONSTANT.substitute(
                constant=convert_constant
            )
        )
    return CONSTANT_LIST.substitute(constant_list="".join(constants_list_part))

def construct_operators(operator_list_from_yaml: List) -> str:
    operator_list_part = []
    for operator in operator_list_from_yaml:
        operator_list_part.append(
            ONE_OPERATOTR_STRING.substitute(
                operator_name=operator[0],
                overload_name=operator[1],
                num_of_args=operator[2],
            )
        )
    return OPERATOR_STRING_LIST.substitute(operator_string_list="".join(operator_list_part))

def construct_types(types_tr_list_from_yaml: List) -> str:
    types_tr_list_part = []
    for types_tr in types_tr_list_from_yaml:
        types_tr_list_part.append(
            ONE_TYPE.substitute(
                type_str=types_tr
            )
        )
    return TYPE_LIST.substitute(type_list="".join(types_tr_list_part))

def construct_register_size(register_size_from_yaml: int) -> str:
    if (not isinstance(register_size_from_yaml, int)):
        raise ValueError(f"Input register size is {register_size_from_yaml} and it's type is {type(register_size_from_yaml)}. An int type is expected.")
    return str(register_size_from_yaml)

def write_cpp(cpp_path, upgrader_dict):
    body_parts = []

    all_upgrader_src_string = []
    for upgrader_bytecode in upgrader_dict:
        for op_name, bytecode in upgrader_bytecode.items():
            instruction_list_str = ""
            constant_list_str = ""
            type_list_str = ""
            register_size_str = ""
            operator_list_str = ""
            for table_name, contents in bytecode.items():
                # print("table name: ", table_name)
                element = ByteCode[table_name]
                body_string = ""
                if element is ByteCode.instructions:
                    instruction_list_str = construct_instruction(contents)
                elif element is ByteCode.constants:
                    constant_list_str = construct_constants(contents)
                elif element is ByteCode.operators:
                    operator_list_str = construct_operators(contents)
                elif element is ByteCode.types:
                    type_list_str = construct_types(contents)
                elif element is ByteCode.register_size:
                    register_size_str = construct_register_size(contents)

            one_upgrader_function_string = ONE_UPGRADER_FUNCTION.substitute(
                upgrader_name=op_name,
                instruction_list=instruction_list_str,
                constant_list=constant_list_str,
                type_list=type_list_str,
                register_size=register_size_str,
            )
            one_upgrader_src_string = ONE_UPGRADER_SRC.substitute(
                bytecode_function=one_upgrader_function_string,
                operator_string_list=operator_list_str,
            )
            all_upgrader_src_string.append(one_upgrader_src_string)

    upgrader_file_content = UPGRADER_CPP_SRC.substitute(
        operator_version_map="a",
        upgrader_bytecode="".join(all_upgrader_src_string))
    body_parts.append(upgrader_file_content)
    print("writing file to : ", cpp_path + "/" + UPGRADER_MOBILE_FILE_NAME)
    with open(
        os.path.join(cpp_path, UPGRADER_MOBILE_FILE_NAME), "wb"
    ) as out_file:
        final_output = "".join(body_parts)
        out_file.write(upgrader_file_content.encode("utf-8"))

def parse_upgrader(upgrader_yaml_path: str) -> Dict:
    upgrader_dict = load_yaml(upgrader_yaml_path)
    return upgrader_dict

def get_parser_options(parser: argparse.ArgumentParser) -> argparse.Namespace:
    parser.add_argument(
        "--input_upgrader_bytecode_yaml",
        type=str,
        help="A path to input yaml file.",
        required=True,
    )
    parser.add_argument(
        "--output_path",
        help=f"Output {UPGRADER_MOBILE_FILE_NAME}.",
        required=True,
    )
    options = parser.parse_args()
    return options


def main(argv):
    parser = argparse.ArgumentParser(description="Generate used operators YAML")
    options = get_parser_options(parser)

    upgrader_bytecode_yaml = options.input_upgrader_bytecode_yaml
    # version_map_yaml = options.input_version_map_yaml
    output_path = options.output_path

    # parse_version_map(version_map_yaml)
    upgrader_dict = parse_upgrader(upgrader_bytecode_yaml)
    write_cpp(options.output_path, upgrader_dict)


if __name__ == "__main__":
    main(sys.argv)
